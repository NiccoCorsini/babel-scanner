# Babel Scanner

**Babel Scanner** is a lightweight yet powerful library designed to encode strings into a custom numeric proprietary code (mapped in memory) and decode the generated codes back into their original strings. This is particularly useful for solving keyboard layout issues across different operating systems, ensuring compatibility between AZERTY, QWERTY, QWERTZ, and other layouts when reading barcode scans.

### Problem Solved

The common barcode type, **Code-128**, follows the ASCII standard. However, most operating systems interpret these barcodes as if they were typed from a keyboard, using the system's current keyboard layout. If the barcode was generated by a device with a different layout, issues can arise when characters are mapped differently between layouts (e.g., AZERTY vs. QWERTY).

Detecting and managing HID input devices directly from the browser is often complex, and operating systems do not allow different keyboard layouts for each connected input device. Babel Scanner helps solve this by encoding and decoding barcodes consistently across different layouts, eliminating the need for device-specific logic in web and client applications.

## Features

- Encode strings into a numeric proprietary code.
- Decode numeric codes back into the original string.
- Ensures compatibility across different keyboard layouts.
- Lightweight and easy to integrate into web and client applications.

## Installation

You can install Babel Scanner via npm:

```bash
npm install babel-scanner
```

## Usage

Babel Scanner exposes two main functions: `readCode` and `writeCode`. Both functions expect a specific format of the input to ensure compatibility. The input for `readCode` should be a string that was generated by `writeCode`, and vice versa. This is the only format that guarantees the functions will work correctly.

### `readCode`

Decodes an encoded string into a readable name and a numeric part.

#### Parameters

- **str** (string): The encoded string to be decoded. The string should contain a name and a numeric part at the end.

#### Returns

- **string**: The decoded name combined with the numeric part of the string.

#### Throws

- **Error**: Throws an error if the string does not start with the expected prefix or if the code is not readable.

#### Example

```javascript
import { readCode } from "babel-scanner";

const decoded = readCode("501511404819504427406427-66");

//returns "PINZI66"
```

### `writeCode`

Encodes a name and numeric part into a proprietary numeric code using a specific prefix and encoding map.

#### Parameters

- **str** (string): The string containing a name and numeric part that need to be encoded.

#### Returns

- **string**: The encoded string, consisting of an encoded prefix and the numeric part, separated by a specific delimiter.

#### Example

```javascript
import { writeCode } from "babel-scanner";

const encoded = writeCode("PINZI66");

//returns "501511404819504427406427-66"
```

## How It Works

### Encoding

When you use `writeCode`, the function:

1. Takes a name and numeric part as input.
2. Splits the name into smaller parts based on a defined range.
3. Maps the split parts to their numeric representation using a predefined alphabet map in memory.
4. Prepends a reservation prefix to the encoded name and joins them together with a separator before appending the numeric part.

### Decoding

When you use `readCode`, the function:

1. Extracts the encoded name and numeric part from the input string.
2. Checks and extracts a predefined prefix from the encoded name.
3. Decodes the numeric representation back to the original name using the same alphabet map used during encoding.
4. Combines the decoded name with the numeric part to reconstruct the original input.

## Why Use Babel Scanner?

- **Compatibility**: Ensures that barcodes are interpreted correctly across different keyboard layouts (AZERTY, QWERTY, QWERTZ, etc.).
- **Ease of Use**: No need to add additional logic to detect HID devices in browsers or manage keyboard layouts at the system level.
- **Performance**: Lightweight and efficient, ideal for both web and client-side applications.

## License

This project is licensed under the ISC License. See the LICENSE file for details.

---

Made with ❤️ by [Opentrentuno](https://opentrentuno.it).
